![Markdown Logo](assets/images/algorithms-and-data-structres.jpg)
<small>Visual: Unsplash / Lorenzo Herrera</small>
<br/><br/>

<div align="center">

# **Algorithms and data structres üß±**
 Learn and master Algorithms, Data structres, Asymptotic analysis, Recursion, Dynamic Programming, Divide and conquer and all kina awesomeness üßÉ

<br>


[![Maintenance](https://img.shields.io/badge/Maintained%3F-yes-green.svg)](https://GitHub.com/Naereen/StrapDown.js/graphs/commit-activity) [![Ask Me Anything !](https://img.shields.io/badge/Ask%20me-anything-1abc9c.svg)](https://github.com/humamaboalraja) [![MIT license](https://img.shields.io/badge/License-MIT-blue.svg)](https://lbesson.mit-license.org/)


</div>

---

<br/>

## - [**Table of content**](#table-of-content)

  - 1 . [Getting started](#getting-started)
  - 2 . [Learning Checklist ‚úÖ](#learning-checklist-)
  - ## 4 . [Algorithms Applications & theory](#algorithms-applications-&-theory)
    - 1 . [Asymptotic Analysis](#asymptotic-analysis)
      - 1.1 [Time Complexity](#time-complexity)
      - 1.2 [Space Complexity](#space-complexity)
      - 1.3 [Memory](#memory)
    - 2 . [Asymptotic notations](#asymptotic-notations)
      - 1 . [Big-O notation (O)](#big-O-notation-(O))
      - 2 . [Omega notation (Œ©)](#omega-notation-(Œ©))
      - 3 . [Theta notation (Œò)](#theta-notation-(Œò))
    - 4 . [Algorithm Design Techniques & Strategies](#algorithm-design-techniques-&-strategies)
    - 6 . [Searching Algorithms](#searching-algorithms)
      - 1 . [Linear Search](#linear-search)
      - 2 . [Binary Search](#binary-search)
      - 3 . [Jump Search](#jump-search)
      - 4 . [A* search algorithm](#a*-search-algorithm)
    - 5 . [Recursion (Recursive Algorithms)](#recursion-(recursive-algorithms))
    - 7 . [Sorting Algorithms](#sorting-algorithms)
      - 1 . [Bubble Sort](#bubble-sort)  
      - 2 . [Selection Sort](#selection-sort)  
      - 3 . [Insertion Sort](#insertion-sort)  
      - 3 . [Merge Sort](#merge-sort)  
      - 4 . [Quick Sort](#quick-sort)  
      - 4 . [Radix Sort](#radix-sort)  
      - 4 . [Shell Sort](#shell-sort)  
    - 8 . [Graph Algorithms](#graph-algorithms)
      - 1 . [Breadth-first search](#breadth-first-search)
      - 2 . [Depth-first search](#depth-first-search)
      - 3 . [Dijkstra‚Äôs shortest path algorithm]()
      - 4 . [Bellman‚ÄìFord algorithm](#bellman‚Äìford-algorithm)
    - 9 . [Greedy Algorithms](#greedy-algorithms)
    - 10 . [Divide and Conquer](#divide-and-conquer)
    - 11 . [Dynamic Programming](#dynamic-programming)
    - 12 . [Backtracking](#backtracking)
  - ## 5 . [Data structres](#data-structres)
    - 1  . [What are Data structres?](#what-are-data-structres?)
    - 2  . [Complexity analysis](#complexity-analysis)
    - 3  . [Memory](#memory)
    - 4  . [Logarithm](#logarithm)
    - 5  . [Difference between Linear and Non-linear Data Structures](#difference-between-linear-and-non-linear-data-structures)
    - 6  . [Arrays](#arrays)
    - 7  . [Linked lists](#linked-lists)
      - 7.1  . [Singly Linked lists](#singly-linked-lists)
      - 7.2  . [Doubly Linked lists](#doubly-linked-lists)
      - 7.2  . [Circular Linked lists](#circular-linked-lists)
    - 8  . [Hash tables](#hash-tables)
    - 9  . [Stacks](#stacks)
    - 10 . [Queues](#queues)
    - 11 . [Trees](#trees)
      - 11.1 . [Binary search trees](#binary-search-trees)
      - 11.2 . [AVL Trees](#avl-trees)
      - 11.3 . [Heaps](#heaps)
    - 12 . [Tries](#tries)
    - 14 . [Graphs](#graphs)
    - 15 . [Strings](#strings)
    - 16 . [Priority Queue](#priority-queue)
    - 17 . [Dictionaries](#dictionaries)
    
    <br>

    #### **Further Learning Resource**

  - 9 . [Articles üì∞](#-articles-)
  - 10 . [Books üìö](#-books-)
  - 11 . [Courses üíª](#-courses-)

---

<br/>

# 1

## **Getting started**

<details open>
  <summary>Let's first get to know why do we need this thing ü•∏ | <b>Click to expand</b></summary>
</br>

### **Why do you need any of this**


---

</details>
<br/>
<br/>
<br/>







# 2
## **Learning Checklist ‚úÖ**

<details open>
  <summary>A handy checklist to keep track of your progress, and know when you master your Algorithms and data strucres path üíà. <b>Click to expand</b></summary>
</br>

### **Algorithms**:
Show that you:
- [ ]  Know how to analyze algorithms
- [ ]  Know what is algorithm time complexity
- [ ]  Applied these concepts to searching and sorting algorithms

### **Data structures**:
For each of the data structures listed below, you have to understand their functionality, including common operations and their time complexities; what are their strengths and their limitations and, finally, how they are used in real-world scenarios.

- [ ]  Arrays
  - [ ] Traversing, Searching, Insertion, Deletion, Size
- [ ]  Stacks
  - [ ]  Push, Pop, is empty, top
- [ ]  Queues
- [ ]  Linked Lists
- [ ]  Hash tables
- [ ]  Graphs
- [ ]  Trees
- [ ]  Tries



</details>

---

<br/>
<br/>



<div align="center">

# 3
## **Algorithms Applications & theory**

<br>


![](https://media.giphy.com/media/6wa5vuYvetU1Jibm13/source.gif)
---
</div>
 <h2>Algorithm</h2> 

noun, UK  /Àà√¶l.…°…ô.r…™.√∞…ôm/ US  /Àà√¶l.…°…ô.r…™.√∞…ôm/

>a process, step-by-step procedure or set of rules to be followed in calculations or other problem-solving operations to be executed in a certain order to get the desired output, especially by a computer, and those can be simple processes, such as multiplying two numbers, or a complex operation, such as playing  compressed video file. or a Search engine that uses proprietary algorithms to display the most relevant results from its search index for specific queries.


**<small>Cambridge dictionary/ Oxford Languages</small>**


- **What:** Algorithms are a part of daily life actions, and those daily actions and everything we do is the simplest form to represent what an Algorithm is, e.g Finding you car in a parking lot , cleaning your Apartment, reading a book.
  
  ---



- **Applications**: The real power of Algorithms come in form of Digital tools, Softwares or small computer programs like, Compression algorithms in a 3D video game or Searching algorithms in Google Search engine, or sorting algorithms to sort Amazon's products based on their ratings and all the other services and digital tools that you use on daily bases.

___

- **Efficiency**: Not all algorithms are created equal, and the tricky part of an Algorithm is that there are plenty of algorithms that solve the same problem at the end, but one of them is the most efficint one to use in that spesific problem case, so to know which solution to choose and to be able to compare them, these Algorithms most be analyzed, and before before analyuzing there an important thing that you need to know what makes a good algorithm is the two most important criteria which are that it solves a problem and it does so efficintly.

    ---
- **Measuring Efficiency**: so the way we measure the effecincy of an algorithm is through using a scientific mathematical technique called **```Asymptotic analysis```**, which allows algorithms to be compared independently of a particular programming language or hardware, which will next tell us that some algorithms are  more efficient than others.


</details>

---

<br/>
<br/>




## **Asymptotic Analysis**:

</br>

**Asymptotic analysis** of an algorithm refers to defining the mathematical boundation/framing of its run-time performance. 

- Using asymptotic analysis, we can very well conclude the best case, average case, and worst case scenario of an algorithm. 


- Complexity analysis is effectively used to determine how "good, efficent, scalable, fits the design case best" an algorithm is and whether it's "better" than another one.

- determining how efficient an algorithm is usually involves finding both the **time** complexity and **space** complexity of an Algorithm.

  ---

  <br>
  <div align="center">

  ![](https://media.giphy.com/media/3owzW5c1tPq63MPmWk/giphy.gif)

  ## **But before that what Asymptotic Analysis is about?**
  
  </div>
  <br>

- The idea of Asymptotic complexity and looking at an asymptotic behavior is that we want to see how does the graph behave getting into very large inputs (n) values, and this is simply the idea of asymptotic complexity. 
  
- So why don‚Äôt we in this case to save some time measure the **elapsed real time**, like for instance measuring how fast your code ran on your machine which can tell you how strong your algorithm is!? Because it's not the effecint approach to approach Complexity analysis.

- in computer science problems are often applied at a grand scale like for instance if we are writing an algorithm to optimize whatever part of **Google‚Äôs** search engine it‚Äôs going to be used across billions of users, and there will be large inputs to the algorithms. 
  
- Our most important point is to see how does this algorithm behave on the tail end ( as (input) gets very large), cause we can only see the true measure of performance of an algorithm when we have very large data input, and that why asymptotic complexity analysis intrigues us ‚ù§Ô∏è 

- So in order to be able to indicate the correct Asymptotic Analysis of an algorithm there are some rules that you need to follow: 

  1. 
  2. 
  3. 
  4. 







</details>
<br/>

### **Time complexity**:
<details>
  <summary>What time complexity is? | <b>Click to expand</b></summary>
</br>
</details>

</br></br>


### **Space complexity**:
<details>
  <summary>What time complexity is? | <b>Click to expand</b></summary>
</br>
</details>


</br></br>


### **Memory**:
<details>
  <summary>What you need to know about memory? | <b>Click to expand</b></summary>
</br>
</details>

</br>

---

<br/>
<br/>




## **Asymptotic Notation**:





</br>
</br>


- ### **Big-O notation (O)**:
  <details>
    <summary>What is Big-O notation (O) with code examples | <b>Click to expand</b></summary>

    <br>

   <!-- <details open> -->
    ![](assets/images/asymptotic_notation/big_o/big-o-notation.png)
    </br>
    

  1. ### **Big O cheatsheet**


      <details>
        <summary>Big-O Complexity table ‚ú® | <b>Click to expand</b></summary>
        </br>

      Big O Notation	| Name | Example(s) | Efficiency | Code example|
      |----------------|------|-----------| -------| ----|
      O(1) | Constant | 	Odd or Even number, <br> Look-up table (on average) | üü© | Python, Javascript
      O(log(n)) | Logarithmic | Finding element on sorted array with binary search | üü© | Python, Javascript
      O(n) | Linear | Find max element in unsorted array. <br> Duplicate elements in array with Hash Map | üü© | Python, Javascript
      O(nlog(n)) | Linearithmic | Python, Javascriptorting elements in array with merge sort | üü© | Python, Javascript
      O(n<sup>2</sup>) | Quadratic | # Duplicate elements in array **(na√Øve)**, <br> Sorting array with bubble sort | üü® | Python, Javascript
      O(n<sup>3</sup>) | Cubic | 3 variables equation solver | üü® | Python, Javascript
      O(2<sup>n</sup>) | Exponential | Find all subsets | üü• | Python, Javascript
      O(n!) | Factorial | Find all permutations of a given set/string | üü• | Python, Javascript
      </details>

      ---
  <br>

  2. ### **Big O code examples**

      <details>
        <summary> Python üêç | <b>Click to expand</b></summary>
        <br>

        ## **1.** O(N) time complexity</div>

        <small>Linear Search/ [Programming Simplified](programmingsimplified.com)</small>
        ![](assets/images/algorithms/linear-search.gif)
        


        ```python

        '''
        Sample input/ Output:

        Input : arr[] = {10, 20, 80, 30, 60, 50, 
                  110, 100, 130, 170}
                  x = 110;
        Output : 6
        Element x is present at index 6
        _________________

        Input : arr[] = {10, 20, 80, 30, 60, 50, 
                    110, 100, 130, 170}
                  x = 175;
        Output : -1
        Element x is not present in arr[].
        ___________________________________
      
      Steps:

      - Start from the leftmost element of arr[] and one by one compare x with each element of arr[] 

      - If x matches with an element, return the index.

      - If x doesn‚Äôt match with any of elements,return -1.

      Steps extended:

      Step 1: Set i to 1
      Step 2: if i > n then go to step 7
      Step 3: if A[i] = x then go to step 6
      Step 4: Set i to i + 1
      Step 5: Go to Step 2 |The linear fashion|
      Step 6: Print Element x Found at index i and go to step 8
      Step 7: Print element not found
      Step 8: Exit

      The time complexity of linear search algorithm is O(n) cause it's looking for the data in a linear fashion,
      
      which means it will keep on looking until it matches with the given input.

      
      '''      

       def linearSearch(arr, x):
           # Linearly search x in arr[] 
           for i in range(len(arr)): # o(n) linear time
               # If x is present, which is our input for the function
               if arr[i] == x:
                   # then return its location 
                   return i

           return -1

       listOfItemsToSearchIn = [2,9,35,16,2,7,8,22,35,46,57,68,34,213,4,13] # Size N = 16

       matchedIndex = linearSearch(listOfItemsToSearchIn, 13)

       print(matchedIndex)

       # Result: 15

        ```

      </details>
    </details>

  ---
  <br>

  ### **Omega notation (Œ©)**:
  <details open>
    <summary>What is Omega notation (Œ©) | <b>Click to expand</b></summary>
    </br>
  </details>

  ---

  <br>

  ### **Theta notation (Œò)**:
  <details open>
    <summary>What Asymptotic Analysis is? | <b>Click to expand</b></summary>
    </br>
  </details>

<br/>

---

<br/>
<br/>




## **Algorithm design strategies & Techniques**:

<details open>
  <summary>What Asymptotic Analysis is? | <b>Click to expand</b></summary>
</br>

</details>
<br/>
<br/>
<br/>

---

<br/>
<br/>


<div align="center">

## **Searching Algorithms**:

<details open>
  <summary>What Asymptotic Analysis is? | <b>Click to expand</b></summary>
</br>

</details>
<br/>
<br/>
<br/>

---

<br/>
<br/>

</div>


### **Asymptotic Analysis**:

<details open>
  <summary>What Asymptotic Analysis is? | <b>Click to expand</b></summary>
</br>

</details>
<br/>
<br/>
<br/>





# 8
## **Articles üì∞**

___

Article           | Provider (Platform) | Used as reference|
--------------------- | -------------- | -------|
[Data Structures - Asymptotic Analysis](https://www.tutorialspoint.com/data_structures_algorithms/asymptotic_analysis.htm) | Tutorialspoint | Yes

___
<br/><br/><br/>

# 9
## **Books üìö**
One of the most straight to the point Books üî•üïπüìü
___

Book name           | Provider (Platform) | Author| Skill level |  Cost
--------------------- | -------------- | -------- | ---------- | -----
[The Algorithm Design Manual](https://www.amazon.com/-/en/Steven-S-S-Skiena/dp/1849967202) | Amazon | Steven S S. Skiena | Intermediate | $75.98 |
[Grokking Algorithms: An Illustrated Guide for Programmers and Other Curious People](https://www.amazon.com/-/en/Aditya-Bhargava/dp/1617292230) | Amazon | Aditya Bhargava | Beginner | $39.86 |
___

<br/> 

# 10

## **Courses üíª**
----
The most popular courses that teach Algorithms and data structres. Yes for real üî•üïπüìü

Course name           | Provider (Platform) | Duration| Skill level | Course Cost
--------------------- | -------------- | -------- | ---------- | -----
[Intro to Data Structures and Algorithms](https://www.udacity.com/course/data-structures-and-algorithms-in-python--ud513) | [Udacity]([educative.io](https://www.udacity.com/)) | 4 | Beginner | Free |
[Ace the Python Coding Interview](https://www.educative.io/path/ace-python-coding-interview) | [educative](educative.io) | 21h | Beginner |  |

---

<br/><br/><br/>

# 11

<!-- Tables -->
## **Resources**
**Resources** to learn Algorithms and data structres from üê±
<br/>

---
<br/>

> Learn by watching/ doing
>
Title | Description
------------ | -------------
[YouTube channel: Back To Back SWE](https://www.youtube.com/channel/UCmJz2DV1a3yfgrR7GqRtUUA) | A very helpful youtube channel to learn and understand Asymptotic Bounding, logratihms, sorting algorithms etc..
[Animated Algorithms and Data Structures by Chris Laux.](https://www.chrislaux.com/) | A interactive website explaining some sorting algorithms and some data structures.
---
